#!/usr/bin/env bash
# Kubernetes Without Magic

SCRIPT_PATH="$(cd "$(dirname "$0")"; pwd -P)"
SCRIPT_NAME="$(basename -- "$0")"
if [[ ! -t 1 ]]; then
  STDOUT_IS_TERMINAL=false
else
  STDOUT_IS_TERMINAL=true
fi
DISPLAY=var-show

main() {
  local command=$1

  if [[ $command = connect ]]; then connect ${@:2}; exit 0; fi
  if [[ $command = define ]]; then define ${@:2}; exit 0; fi
  if [[ $command = env ]]; then env ${@:2}; exit 0; fi
  if [[ $command = info ]]; then render usage info; exit 0; fi
  if [[ $command = install ]]; then
    echo "export PATH=\$PATH:$SCRIPT_PATH"
    exit 0;
  fi
  if [[ $command = manifest ]]; then manifest ${@:2}; exit 0; fi
  if [[ $command = script ]]; then script ${@:2}; exit 0; fi
  if [[ $command = startup ]]; then script startup; exit 0; fi

  render usage main
  exit 0
}

var-show() {
  local key=$1
  local value=$2
  if [[ -z $value ]]; then
    value=${!key}
  fi
  printf "$key=\"${value}\"\n"
}

var-validate() {
  local key=$1
  local defaultValue=$2
  local envValue=${!key}
  local value=${envValue:-${defaultValue}}
  if [[ -z $value ]]; then
    printf "$key\n"
  fi
}

var-help() {
  local var=$1
  local value=${!var}
  render definition $var
  printf "\n"
}

compile() {
  echo "SCRIPT_PATH=$SCRIPT_PATH"
  echo "STDOUT_IS_TERMINAL=$STDOUT_IS_TERMINAL"
  echo "DISPLAY=$DISPLAY"
  echo "SCRIPT_NAME=$SCRIPT_NAME"
  echo "cat <<RENDER"
  cat "$1"
  echo "RENDER"
}

render() {
  local namespace=$1
  local key=$2
  local template="$SCRIPT_PATH/package/$namespace/$key"
  if [[ ! -f $template ]]; then
    echo "$namespace $key not found."
    render usage $namespace
    exit 1
  fi
  compile $template | bash
}

highlight() {
  if $STDOUT_IS_TERMINAL; then
    for name in ${!KWM*}; do
      eval $name=\"$(tput setaf 4)${!name}$(tput op)\"
    done
  fi
}

upper-case() {
  awk '{print toupper($0)}' <<< "$1"
}

find-vars() {
  printf "$(declare -xp | grep "$1" | sed 's/declare -x \(.*\)=.*/\1/g')"
}

hash-from-var() {
  sed 's/.*_\(.*\)/\1/' <<< $1
}

find-host-hashes() {
  local type=$1
  for hit in $(find-vars "KWM_HOST_ROLE*"); do
    local hash="${hit##*_}"
    if [[ $type == all || -z $type ]]; then
      echo $hash
    elif grep -q $type <<<${!hit}; then
      echo $hash
    fi
  done
}

host-value() {
  local hash=$1
  local key=$2
  local lookup="KWM_HOST_${key}_${hash}"
  echo ${!lookup}
}

get-defaults() {
  export KWM_BASE_PATH=${KWM_BASE_PATH:-/etc/kubernetes}
  export KWM_LOCAL_PKI_PATH=${KWM_LOCAL_PKI_PATH:-pki}
}

get-host-meta() {
  local hash=$1
  export KWM_ROLE="$(host-value $hash ROLE)"
  export KWM_HOSTNAME="$(host-value $hash NAME)"
  export KWM_CONNECT="$(host-value $hash CONNECT)"
  export KWM_PRIVATE_IP="$(host-value $hash PRIVATE_IP)"
}

get-etcd-meta() {
  export KWM_ETCD_INITIAL_CLUSTER=$(etcd-initial-cluster)
  export KWM_ETCD_CLIENT_SUBJECT_ALTNAMES=$(etcd-client-subjectaltnames)
  export KWM_ETCD_HOSTS=$(etcd-hosts)
}

etcd-client-subjectaltnames() {
  local output
  if [[ -n $KWM_ETCD_CLIENT_SUBJECT_ALTNAMES ]]; then
    echo $KWM_ETCD_CLIENT_SUBJECT_ALTNAMES
  else
    for hash in $(find-host-hashes etcd); do
      output+=",IP:$(host-value $hash PRIVATE_IP),DNS:$(host-value $hash NAME)"
    done
    echo ${output:1}
  fi
}

etcd-initial-cluster() {
  local output
  if [[ -n $KWM_ETCD_INITIAL_CLUSTER ]]; then
    echo $KWM_ETCD_INITIAL_CLUSTER
  else
    for hash in $(find-host-hashes etcd); do
      output+=",$(host-value $hash NAME)=https://$(host-value $hash PRIVATE_IP):2380"
    done
    echo ${output:1}
  fi
}

etcd-hosts() {
  local output
  if [[ -n $KWM_ETCD_HOSTS ]]; then
    echo $KWM_ETCD_HOSTS
  else
    for hash in $(find-host-hashes etcd); do
      output+=",https://$(host-value $hash PRIVATE_IP):2379"
    done
    echo ${output:1}
  fi
}

connect() {
  local hash=$1
  if [[ -z $hash ]]; then
    render usage connect
    export valid="$(find-host-hashes $type)"
    export command="kwm connect [hash]"
    render error missing-hash
    exit 1
  fi
  $(host-value $hash CONNECT)
}

define() {
  local var=$1
  if [[ -z $var ]]; then
    render usage define
    exit 1
  fi
  render definition $var
}

env() {
  local type=$1
  local hash=$2
  if [[ -z $type ]]; then
    render usage env
    exit 1
  fi
  if [[ -z $hash && $type =~ ^(etcd|controlplane|worker)$ ]]; then
    export valid="$(find-host-hashes $type)"
    export command="kwm env $type [hash]"
    render error missing-hash
    exit 1
  fi
  get-defaults
  get-host-meta $hash
  get-etcd-meta
  highlight
  render env $type
}

manifest() {
  local type=$1
  if [[ -z $type ]]; then
    render usage manifest
    exit 1
  fi
  highlight
  render manifest $type
}

script() {
  local type=$1
  local hash=$2
  if [[ -z $type ]]; then
    render usage script
    exit 1
  fi
  if [[ ! -z $hash && $type =~ ^(etcd|controlplane|worker)$ ]]; then
    get-host-meta $hash
  fi
  get-etcd-meta
  get-defaults
  local errors=$(DISPLAY=var-validate render env $type)
  if [[ -n $errors ]]; then
    errors="$errors" type="$type" command=$command render error env-missing
    exit 1
  fi
  highlight
  render script $type
}

export -f \
  var-help \
  var-validate \
  var-show \
  compile \
  render \
  host-value \
  find-host-hashes \
  find-vars \
  upper-case \
  hash-from-var

main "$@"
