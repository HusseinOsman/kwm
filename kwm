#!/bin/bash

here="$(dirname "$0")"

source $here/src/check-overwrite.sh
source $here/src/cluster-pki.sh
source $here/src/etcd-install.sh
source $here/src/controlplane-install.sh
source $here/src/header.sh
source $here/src/render.sh
source $here/src/review.sh
source $here/src/validate.sh
source $here/src/worker-install.sh

function main {
  local cmd=$1
  local subcmd=$2

  if ([ -z "$cmd" ] && [ -z "$subcmd" ]); then
    echo "$(cat <<EOF
$(header "Welcome to Kubernetes Without Magic!")

The easiest way to get started is to generate your config files and run this
command "next" to them (that is, in the same directory):

$(header "kwm bootstrap")

If you would like to provide a configuration path explictly, do so thusly:

$(header "KWM_CONFIG_PATH=path/to/configs kwm bootstrap")

Either of these approaches will output the next series of commands needed to
provision your cluster.
EOF
)"
    exit 0
  fi

  if [ "$cmd" == "render" ]; then
    if [ -z "$KWM_TYPE" ]; then
      echo "Please specify a type of output to render."
      exit 1
    fi
    eval "$KWM_TYPE"
    exit 0
  fi

  eval "$cmd"

  #header "Configure your controlplane:"
  #printf "$controlPlaneInstall"

  #header "Confirm controlplane is running:"
  #printf "kubectl get componentstatus\n"

  #header "Configure your workers:"
  #printf "$workerInstall"

  #header "Configure DNS:"
  #printf "Make A record for $KWM_DOMAIN to $KWM_APISERVER_PRIVATE_IP_PUBLIC_IP."
}

function bootstrap {
  local configs=$(realpath ${KWM_CONFIG_PATH:-$PWD})
  shopt -s nullglob
  for config in $configs/*.env; do
    source $config
    local configRelative=$(realpath $config --relative-to=$PWD)
    echo "env -S \"\$(<$configRelative)\" kwm render | bash"
  done
}

function pki {
  cluster-pki clusterName:="$KWM_NAME" etcdClientSubjectNames:="$KWM_ETCD_CLIENT_SUBJECT_NAMES"
}

function root-access {
  render script contents:="$(
    render log message:="Configuring kubectl for root access to cluster."
    render kubectl-root-access clusterName:="$KWM_NAME" apiserver:="$KWM_PUBLIC_IP"
  )"
}

function manifests {
  render manifest-kube-dns version:="$KWM_VERSION_KUBE_DNS" serviceIp:="$KWM_DNS_SERVICE_IP"
}

function etcd {
  etcd-install \
    exec:="$KWM_EXEC" \
    name:="$KWM_HOSTNAME" \
    basePath:="/etc/kubernetes" \
    privateIp:="$KWM_PRIVATE_IP" \
    initialCluster:="$KWM_ETCD_INITIAL_CLUSTER" \
    version:="$KWM_VERSION_ETCD"
}

function controlplane {
  controlplane-install \
    exec:="$KWM_EXEC" \
    name:="$KWM_HOSTNAME" \
    basePath:="/etc/kubernetes" \
    privateIp:="$KWM_PRIVATE_IP" \
    serviceCidr:="$KWM_SERVICE_CIDR" \
    clusterName="$KWM_NAME" \
    podCidr:="$KWM_POD_CIDR" \
    etcdHosts:="$KWM_ETCD_HOSTS" \
    kubernetesServiceIp:="$KWM_KUBERNETES_SERVICE_IP" \
    loadBalancerIp:="$KWM_PUBLIC_IP" \
    count:="1" \
    version:="$KWM_VERSION_KUBERNETES"
  worker
}

function worker {
  worker-install \
    exec:="$KWM_EXEC" \
    name:="$KWM_HOSTNAME" \
    basePath:="/etc/kubernetes" \
    privateIp:="$KWM_PRIVATE_IP" \
    criContainerdVersion:="$KWM_VERSION_CRI_CONTAINERD" \
    cniPluginVersion:="$KWM_VERSION_CNI_PLUGIN" \
    clusterName:="$KWM_NAME" \
    apiserver:="$KWM_APISERVER_PRIVATE_IP" \
    kubernetesVersion:="$KWM_VERSION_KUBERNETES" \
    podCidr:="$KWM_POD_CIDR" \
    dnsServiceIp:="$KWM_DNS_SERVICE_IP" \
    role:="$KWM_ROLE"
}
main "$@"
