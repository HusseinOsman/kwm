#!/usr/bin/env bash

SCRIPT_PATH="$(cd "$(dirname "$0")"; pwd -P)"
SCRIPT_NAME="$(basename -- "$0")"
if [[ ! -t 1 ]]; then
  STDOUT_IS_TERMINAL=false
else
  STDOUT_IS_TERMINAL=true
fi
VALIDATE=false

main() {
  local command=$1
  if [[ $command == connect ]]; then connect ${@:2}; exit 0; fi
  if [[ $command == define ]]; then define ${@:2}; exit 0; fi
  if [[ $command == env ]]; then getenv ${@:2}; exit 0; fi
  if [[ $command == help ]]; then render usage help; exit 0; fi
  if [[ $command == nodes ]]; then nodes ${@:2}; exit 0; fi
  if [[ $command == install ]]; then
    echo "export PATH=\$PATH:$SCRIPT_PATH"
    exit 0;
  fi
  if [[ $command == manifest ]]; then manifest ${@:2}; exit 0; fi
  if [[ $command == script ]]; then script ${@:2}; exit 0; fi
  if [[ $command == startup ]]; then startup; exit 0; fi
  if [[ $command == unset ]]; then unsetter; exit 0; fi
  render usage main
  exit 0
}

display() {
  local key=$1
  local defaultValue=$2
  local envValue=${!key}
  local value=${envValue:-$defaultValue}
  if [[ $VALIDATE == false || ($VALIDATE == true && -z $value) ]]; then
    printf "$key=\"$value\"\n"
  fi
}

compile() {
  echo "SCRIPT_PATH=$SCRIPT_PATH"
  echo "STDOUT_IS_TERMINAL=$STDOUT_IS_TERMINAL"
  echo "VALIDATE=$VALIDATE"
  echo "SCRIPT_NAME=$SCRIPT_NAME"
  echo "cat <<RENDER"
  cat "$1"
  echo "RENDER"
}

render() {
  local namespace=$1
  local key=$2

  local template="$SCRIPT_PATH/package/$namespace/$key"
  if [[ ! -f $template ]]; then
    missing=$key error resource-not-found
    printf "\n"
    render usage $namespace
    exit 1
  fi
  compile $template | bash
}

error() {
  (tput setaf 1; render error $1; tput op) >&2
}

highlight() {
  if $STDOUT_IS_TERMINAL; then
    for name in ${!KWM*}; do
      eval $name=\"$(tput setaf 4)${!name}$(tput op)\"
    done
  fi
}

validate-env() {
  local method=$1
  local type=$2
  local errors="$(VALIDATE=true render env $type)"
  if [[ -n $errors ]]; then
    errors="$errors" type="$type" method="$method" error env-missing
    exit 1
  fi
}

find-vars() {
  printf "$(declare -xp | grep "$1" | sed 's/declare -x \(.*\)=.*/\1/g')"
}

find-nodes() {
  local type=$1
  for hit in $(find-vars "KWM_ROLE_.*"); do
    local node="${hit##*_}"
    if [[ $type == all || ${!hit} =~ $type ]]; then
      echo $node
    fi
  done
}

node-value() {
  local node=$1
  local var=$2
  local nodeLookup="KWM_${var}_${node}"
  local defaultLookup="KWM_${var}"
  local nodeValue=${!nodeLookup}
  local defaultValue=${!defaultLookup}
  echo ${defaultValue:-$nodeValue}
}

magic-node-meta() {
  local node=$1
  export KWM_ROLE="${KWM_ROLE:-$(node-value $node ROLE)}"
  export KWM_HOSTNAME="${KWM_HOSTNAME:-$(node-value $node HOSTNAME)}"
  export KWM_CONNECT="${KWM_CONNECT:-$(node-value $node CONNECT)}"
  export KWM_PRIVATE_IP="${KWM_PRIVATE_IP:-$(node-value $node PRIVATE_IP)}"
  export KWM_KUBELET_FLAGS="${KWM_KUBELET_FLAGS:-$(magic-kubelet-flags $node)}"
}

magic-kubelet-flags() {
  local node=$1
  local roles="$(node-value $node ROLE)"
  local output
  for role in $roles; do
    output+=",node-role.kubernetes.io/$role=true"
  done
  [[ -n $output ]] && output="--node-labels=\"${output:1}\""
  if [[ $roles == *"controlplane"* && $roles != *"worker"* ]]; then
    output+=" --register-with-taints=\"node-role.kubernetes.io/controlplane=true:NoSchedule\""
  fi
  [[ -n $output ]] && echo "$output"
}

magic-etcd-meta() {
  export KWM_ETCD_INITIAL_CLUSTER=${KWM_ETCD_INITIAL_CLUSTER:-$(magic-etcd-initial-cluster)}
  export KWM_ETCD_CLIENT_SANS=${KWM_ETCD_CLIENT_SANS:-$(magic-etcd-client-sans)}
  export KWM_ETCD_SERVERS=${KWM_ETCD_SERVERS:-$(magic-etcd-servers)}
}

magic-etcd-client-sans() {
  local output
  for node in $(find-nodes etcd); do
    output+=",IP:$(node-value $node PRIVATE_IP),DNS:$(node-value $node HOSTNAME)"
  done
  [[ -n $output ]] && echo ${output:1}
}

magic-etcd-initial-cluster() {
  local output=""
  for node in $(find-nodes etcd); do
    output+=",$(node-value $node HOSTNAME)=https://$(node-value $node PRIVATE_IP):2380"
  done
  [[ -n $output ]] && echo ${output:1}

}

magic-etcd-servers() {
  local output
  for node in $(find-nodes etcd); do
    output+=",https://$(node-value $node PRIVATE_IP):2379"
  done
  [[ -n $output ]] && echo ${output:1}
}

connect() {
  local node=$1
  local call
  call=$(node-value $node CONNECT) || return
  if [[ -z $node ]]; then
    render usage connect
    exit 1
  fi
  if [[ -z $call ]]; then
    requested=$node error invalid-node
    exit 1
  fi
  $call
}

define() {
  local var=$1
  if [[ -z $var ]]; then
    vars="$(ls $SCRIPT_PATH/package/define)" render usage define
    exit 1
  fi
  echo $var
  render define $var
}

getenv() {
  local type=$1
  local node=$2
  if [[ -z $type ]]; then
    render usage env
    exit 1
  fi
  if [[ $type =~ node ]]; then
    magic-node-meta $node
    if [[ -z $node ]]; then
      type=$type error no-node-for-env
      printf "\n"
    fi
  fi
  magic-etcd-meta
  highlight

  render env $type
}

nodes() {
  local role=$1
  if [[ -z $role ]]; then
    render usage nodes
    exit
  fi
  local nodes="$(find-nodes $role)"
  if [[ -z $nodes ]]; then
    role=$role error no-nodes-for-role
    exit 1
  fi
  echo "$nodes"
}

manifest() {
  local type=$1
  if [[ -z $type ]]; then
    render usage manifest
    exit 1
  fi
  validate-env manifest $type
  highlight
  render manifest $type
}

script() {
  local type=$1
  local node=$2
  if [[ -z $type ]]; then
    render usage script
    exit 1
  fi
  magic-etcd-meta
  if [[ $type =~ node ]]; then
    magic-node-meta $node
  fi
  validate-env script $type
  highlight
  render script $type
}

startup() {
  validate-env script startup
  if [[ -z "$(find-nodes etcd)$(find-nodes controlplane)$(find-nodes worker)" ]]; then
    error startup-no-nodes
    exit 1
  fi
  magic-etcd-meta
  render script startup
}

unsetter() {
  if $STDOUT_IS_TERMINAL; then
    render usage unset
    exit 0
  fi
  env | grep KWM_.*\= | cut -f1 -d= | xargs -n 1 echo unset
}

export -f display compile render node-value find-nodes

main "$@"
