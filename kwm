#!/usr/bin/env bash

# prepare some global variables
SCRIPT_PATH="$(cd "$(dirname "$0")"; pwd -P)"
HELP_REQUESTED=false
case "$@" in
  *--help*) HELP_REQUESTED=true ;;
esac
if [ ! -t 1 ]; then
  STDOUT_IS_TERMINAL=false
else
  STDOUT_IS_TERMINAL=true
fi
DISPLAY=var-show
if $HELP_REQUESTED; then
  DISPLAY=var-help
fi

function main {
  local command=$1
  local type=$2
  local index=$3

  if [ "$command" = "context" ]; then context $type $index; exit 0; fi
  if [ "$command" = "go" ]; then script all; exit 0; fi
  if [ "$command" = "info" ]; then render docs info; exit 0; fi
  if [ "$command" = "manifest" ]; then manifest $type; exit 0; fi
  if [ "$command" = "script" ]; then script $type $index; exit 0; fi
  if [ "$command" = "eject" ]; then eject; exit 0; fi
  render docs usage
  exit 0
}

function if-help-requested {
  if $HELP_REQUESTED; then
    printf "$1"
  fi
}

function var-show {
  local key=$1
  local value=$2
  if [ -z "$value" ]; then
    value=${!key}
  fi
  printf "$key=\"${value}\"\n"
}

function var-validate {
  local key=$1
  local value=$2
  if [ -z "$value" ]; then
    printf "$key\n"
  fi
}

function var-help {
  local var=$1
  local value=${!var}
  render definition $var
  printf "\n"
}

function compile {
  local template="$SCRIPT_PATH/package/$1"
  echo "SCRIPT_PATH=$SCRIPT_PATH"
  echo "STDOUT_IS_TERMINAL=$STDOUT_IS_TERMINAL"
  echo "DISPLAY=$DISPLAY"
  echo "cat <<RENDER"
  cat "$template"
  echo "RENDER"
}

function render {
  local namespace=$1
  local key=$2
  compile $namespace/$key | bash
}

function highlight {
  if $STDOUT_IS_TERMINAL; then
    for name in ${!KWM*}; do
      eval $name=\"$(tput setaf 4)${!name}$(tput op)\"
    done
  fi
}
export -f var-help var-validate var-show compile render if-help-requested

function validate {
  local type=$1
  local command=$2
  local errors=$(DISPLAY=var-validate render context $type)
  if [ ! -z "$errors" ]; then
    errors="$errors" type="$type" command=$command render error missing-context
    exit 1
  fi
}

function upper-case {
  awk '{print toupper($0)}' <<< "$1"
}

function find-vars {
  local search=$1
  printf "$(declare -xp | grep "$search" | sed 's/declare -x \(.*\)=.*/\1/g')"
}

function hash-from-var {
  sed 's/.*_\(.*\)/\1/' <<< $1
}

function find-hosts {
  for hit in $(find-vars "KWM_HOST_$(upper-case $1)_HOSTNAME*"); do
    echo $(hash-from-var $hit)
  done
}

function private-ip {
  local lookup="KWM_HOST_$1_PRIVATE_IP_$2"
  echo ${!lookup}
}

function hostname {
  local lookup="KWM_HOST_$1_HOSTNAME_$2"
  echo ${!lookup}
}

function derive-etcd-vars {
  local hostHash privateIp hostname subjectAltnames initialCluster etcdHosts
  for var in $(find-hosts etcd); do
    hostHash=$(hash-from-var $var)
    privateIp=$(private-ip ETCD $hostHash)
    hostname=$(hostname ETCD $hostHash)
    # generate subject altnames for etcd-ca certificate
    subjectAltnames+=",IP:${privateIp},DNS:${hostname}"
    # generate initial cluster config to pass as parameter to etcd unit
    initialCluster+=",${hostname}=https://${privateIp}:2380"
    # generate etcdHosts for kube-apiserver unit
    etcdHosts+=",https://${privateIp}:2379"
  done
  if [ -z "$KWM_ETCD_CLIENT_SUBJECT_ALTNAMES" ]; then
    KWM_ETCD_CLIENT_SUBJECT_ALTNAMES=${subjectAltnames:1}
  fi
  if [ -z "$KWM_ETCD_INITIAL_CLUSTER" ]; then
    KWM_ETCD_INITIAL_CLUSTER=${initialCluster:1}
  fi
  if [ -z "$KWM_ETCD_HOSTS" ]; then
    KWM_ETCD_HOSTS=${etcdHosts:1}
  fi
}

function context {
  local type=$1
  local hash=$2

  if [ -z "$type" ]; then
    render docs context
    exit 1
  fi

  if [ -z "$hash" ]; then
    valid="$(find-hosts $type)" type=$type render error context-missing-hash
    exit 1
  fi

  derive-etcd-vars

  local typeUpperCase=$(upper-case $type)
  HOSTNAME="KWM_HOST_${typeUpperCase}_HOSTNAME_${hash}"
  SSH_IP="KWM_HOST_${typeUpperCase}_SSH_IP_${hash}"
  PRIVATE_IP="KWM_HOST_${typeUpperCase}_PRIVATE_IP_${hash}"

  KWM_HOSTNAME="${!HOSTNAME}" \
  KWM_CONNECT="${KWM_EXEC}${!SSH_IP}" \
  KWM_SSH_IP="${!SSH_IP}" \
  KWM_PRIVATE_IP="${!PRIVATE_IP}" \
  KWM_ETCD_INITIAL_CLUSTER=${KWM_ETCD_INITIAL_CLUSTER} \
  KWM_ETCD_HOSTS=${KWM_ETCD_HOSTS} \
  KWM_ETCD_CLIENT_SUBJECT_ALTNAMES=${KWM_ETCD_CLIENT_SUBJECT_ALTNAMES} \
  render context $type
}

function script {
  local type=$1
  local index=$2
  type=${type:-$KWM_TYPE}
  if [ -z "$type" ]; then
    render docs script
    exit 1
  fi
  highlight
  #validate $type script
  render script $type
}

function manifest {
  local type=$1
  type=${type:-$KWM_TYPE}
  if [ -z "$type" ]; then
    render docs manifest
    exit 1
  fi
  highlight
  validate $type
  render manifest $type
}

main $(sed 's/ --help//g' <<< "$@")
